#+OPTIONS: ^:{} _:{} num:t toc:t \n:t
#+include "../../template-toc.org"
#+title: STL: Algorithm

* copy
#+begin_src c++
template< class InputIterator, class OutputIterator >
OutputIterator copy( InputIterator first, InputIterator last, OutputIterator d_first );
#+end_src
  所做的操作类似为 *d_first = *first, *(d_first+1)=*(first+1) ...
* copy_backward
#+begin_src c++
template< class BidirectionalIterator1, class BidirectionalIterator2 >
BidirectionalIterator2 copy_backward( BidirectionalIterator1 first,
                                      BidirectionalIterator1 last,
                                      BidirectionalIterator2 d_last );
#+end_src
  所做的操作类似为 *d_last=*last, *(d_last-1)=*(last-1),...
  与copy的区别在于指定目的区域的末地址，而copy指定的是首地址。且拷贝顺序不同。
  此函数适用于拷贝区间与目的区间存在交叉，且从前拷贝到后的情况，例如：1-10区间拷贝到5-15，如果用copy函数则 *有可能* 会毁坏数据.
  同理如果从5-15拷贝到1-10如果用copy_backward则 *有可能* 毁坏数据。

  *为什么是有可能?*
  因为两个copy根据其操作对象的不同采用不同的行为，如果是原始指针则采用 *memmove* 方法而此函数由于借助了其它辅助空间所以不会产生覆盖。
#+begin_src c++
     int ary[] = {0,1,2,3,4,5,6};
     copy(ary, ary+3, ary+1);
     for_each(ary, ary+sizeof(ary)/sizeof(int), display<int>()); // 0 0 1 2 4 5 6
#+end_src
  表面上看应该会产生覆盖所以结果应该是 0 0 0 0 4 5 6，但其实结果是 0 0 1 2 4 5 6，原因就是因为原始指针调用的是 memmove.
  由于vector内部typedef value_type* iterator;所以其迭代器也是原始指针，所以也调用的是memmove,不必担心覆盖的问题。
#+begin_src c++
     int ary[] = {0,1,2,3,4,5,6};
     vector<int> ivec(ary, ary+sizeof(ary)/sizeof(int));
     copy(ivec.begin(), ivec.begin()+3, ivec.begin()+1);
     for_each(ivec.begin(), ivec.end(), display<int>()); // 0 0 1 2 4 5 6
#+end_src
  list由于其迭代器非原始指针，故最终调用的是循环复制，所以会造成覆盖。
#+begin_src c++
     list<int> List(ary, ary+sizeof(ary)/sizeof(int));
     typedef list<int>::iterator listiter;
     listiter first=List.begin();
     advance(first,2);
     listiter last=List.end();
     advance(last, -2);
     listiter result=List.begin();
     advance(result,4);
     copy(first, last, result);
     for_each(List.begin(), List.end(), display<int>());        //0 1 2 3 2 3 2 3 2
#+end_src
* copy_n (C++11)
#+begin_src c++
template< class InputIterator, class Size, class OutputIterator>
OutputIterator copy_n(InputIterator first, Size count, OutputIterator result);
#+end_src
* accumulate
#+begin_src c++
template< class InputIterator, class T >
T accumulate( InputIterator first, InputIterator last, T init );
template< class InputIterator, class T, class BinaryOperation >
T accumulate( InputIterator first, InputIterator last, T init,
              BinaryOperation op );
#+end_src
  1. 返回对[first,last)之间的元素和init求和结果。
  2. 与1的区别在于使用op函数而非求和函数。
#+begin_src c++
     int ary[] = {0,1,2,3,4,5,6,7,8};
     // 0+0+1+2...
     cout<<accumulate(ary, ary+sizeof(ary)/sizeof(int), 0)<<endl; // 36
     // 0-0-1-2-3-...
     cout<<accumulate(ary, ary+sizeof(ary)/sizeof(int), 0, minus<int>())<<endl; // -36
#+end_src
* inner_product
#+begin_src c++
template< class InputIterator1, class InputIterator2, class T >
T inner_product( InputIterator1 first1, InputIterator1 last1,
                 InputIterator2 first2, T value );

template<
    class InputIterator1,
    class InputIterator2,
    class T,
    class BinaryOperation1,
    class BinaryOperation2
> T inner_product( InputIterator1 first1, InputIterator1 last1,
                   InputIterator2 first2, T value,
                   BinaryOperation1 op1,
                   BinaryOperation2 op2 );
#+end_src
  1. [first1, last1)与first2开始last1-first1个构成的区间对应的元素相乘后相加。
  2. 1中的相乘改为op2，相加改为op1.
#+begin_src c++
     int ip1[] = {1,2,3};
     int ip2[] = {2,3,4,5,6};
     cout<<inner_product(ip1,ip1+3,ip2, 100)<<endl; // 100+1*2+2*3+3*4=120
     cout<<inner_product(ip1,ip1+3,ip2, 100, minus<int>(), plus<int>())<<endl; // 100-(1+2)-(2+3)-(3+4)=85
#+end_src
* partial_sum
#+begin_src c++
template< class InputIterator, class OutputIterator >
OutputIterator partial_sum( InputIterator first, InputIterator last, OutputIterator d_first );

template< class InputIterator, class OutputIterator, class BinaryOperation >
OutputIterator partial_sum( InputIterator first, InputIterator last, OutputIterator d_first,
                            BinaryOperation op );
#+end_src
  所做的操作为：
#+begin_example
*(d_first)   = *first;
*(d_first+1) = *first + *(first+1);
*(d_first+2) = *first + *(first+1) + *(first+2);
*(d_first+3) = *first + *(first+1) + *(first+2) + *(first+3);
...
#+end_example
  第2个版本中用op操作替换+.
#+begin_src c++
     int ip2[] = {2,3,4,5,6};
     partial_sum(ip2, ip2+5, ostream_iterator<int>(cout, " ")); // 2 5 9 14 20
     partial_sum(ip2, ip2+5, ostream_iterator<int>(cout, " "), minus<int>()); // 2 -1 -5 -10 -16
#+end_src
* adjacent_difference
  与partial_sum相似。只是操作相邻元素。
#+begin_example
*(d_first)   = *first;
*(d_first+1) = (*first+1) - *(first);
*(d_first+2) = (*first+2) - *(first+1);
*(d_first+3) = (*first+3) - *(first+2);
#+end_example

#+begin_src c++
     int ip2[] = {2,3,4,5,6};
     adjacent_difference(ip2, ip2+5, ostream_iterator<int>(cout, " ")); // 2 1 1 1 1
     adjacent_difference(ip2, ip2+5, ostream_iterator<int>(cout, " "), plus<int>()); // 2 5 7 9 11
#+end_src
* equal
#+begin_src c++
template< class InputIterator1, class InputIterator2 >
bool equal( InputIterator1 first1, InputIterator1 last1, 
            InputIterator2 first2 );

template< class InputIterator1, class InputIterator2, class BinaryPredicate >
bool equal( InputIterator1 first1, InputIterator1 last1, 
            InputIterator2 first2, BinaryPredicate p );
#+end_src
  [first1,last1)之间的元素是否与first2开始的同等个数的区间对应元素相同。如果first2开始的元素个数没有first1到last1之间的多则结果不确定。
  第2个版本可以自定义比较操作，默认是相等。
#+begin_src c++
     int ip1[] = {1,2,3};
     int ip2[] = {1,2,3,4,5,6};
     cout<<equal(ip1,ip1+3,ip2)<<endl; // 1
     cout<<equal(ip1,ip1+3,ip2+1)<<endl; // 0
     cout<<equal(ip1,ip1+3,ip2+1, less<int>())<<endl; // 1
#+end_src
* fill
#+begin_src c++
template< class ForwardIterator, class T >
void fill( ForwardIterator first, ForwardIterator last, const T& value );
#+end_src
  用value填充区间[first,last).
* fill_n
#+begin_src c++
template< class OutputIterator, class Size, class T >
void fill_n( OutputIterator first, Size count, const T& value );        //before c++11

template< class OutputIterator, class Size, class T >
OutputIterator fill_n( OutputIterator first, Size count, const T& value ); //C++11
#+end_src
  填充指定位置开始的指定个数元素，C++11中返回值与advance(first,count);相同。
* iter_swap
#+begin_src c++
template< class ForwardIterator1, class ForwardIterator2 >
void iter_swap( ForwardIterator1 a, ForwardIterator2 b );
#+end_src
  交换两个迭代器的内容。调用的是swap函数。
* swap
#+begin_src c++
template< class T >
void swap( T& a, T& b );

template< class T, size_t N >
void swap( T (&a)[N], T (&b)[N]);       //c++11
#+end_src
  swap可交换的对象包含了几乎所有的泛型对象：vector,list,queue...
  C++11的swap调用的是swap_range(a, a+N, b);
* swap_range
#+begin_src c++
template< class ForwardIterator1, class ForwardIterator2 >
ForwardIterator2 swap_ranges( ForwardIterator1 first1,
                              ForwardIterator1 last1, 
                              ForwardIterator2 first2 )
#+end_src
  交换[first1,last1)与first2开始的区间。
  内部调用的是iter_swap。
* lexicographical_compare
#+begin_src c++
template< class InputIterator1, class InputIterator2 >
bool lexicographical_compare( InputIterator1 first1, InputIterator1 last1,
                              InputIterator2 first2, InputIterator2 last2 );

template< class InputIterator1, class InputIterator2, class Compare >
bool lexicographical_compare( InputIterator1 first1, InputIterator1 last1,
                              InputIterator2 first2, InputIterator2 last2,
                              Compare comp );
#+end_src
  以词典序排序。
  先比较 min((last1-first1),(last2-first2)) 个，如果比较出来则返回否则第1个区间短则返回真否则返回假。
* mismatch
#+begin_src c++
template< class InputIterator1, class InputIterator2 >
std::pair<InputIterator1,InputIterator2>
    mismatch( InputIterator1 first1,
              InputIterator1 last1,
              InputIterator2 first2 );

template< class InputIterator1, class InputIterator2, class BinaryPredicate >
std::pair<InputIterator1,InputIterator2>
    mismatch( InputIterator1 first1,
              InputIterator1 last1,
              InputIterator2 first2,
              BinaryPredicate p );
#+end_src
  返回第一次不匹配的第1个区间迭代器和第2个区间迭代器构成的pair.
