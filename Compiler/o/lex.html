<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
               "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh-CN" xml:lang="zh-CN">
<head>
<title>Lex使用</title>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
<meta name="title" content="Lex使用"/>
<meta name="generator" content="Org-mode"/>
<meta name="generated" content="2012-12-02 00:33:39 CST"/>
<meta name="author" content="visayafan"/>
<meta name="description" content=""/>
<meta name="keywords" content=""/>
<div id="org-div-comments"><a href="../../index.html#compiler">主页</a><br/><a href="#disqus_thread">评论</a></div>


</head>
<body>


<div id="content">
<h1 class="title">Lex使用</h1>


<!-- <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"> </script> -->
<link rel="stylesheet" type="text/css" href="../../Layout/CSS/bootstrap_old.css" />
<link rel="stylesheet" type="text/css" href="../../Layout/CSS/vf.css" />
<script src="../../Layout/JS/jquery_1.7.1.js"></script>
<script src="../../Layout/JS/bootstrap_old.js"></script>


<p>
Manual: <a href="http://flex.sourceforge.net/manual">http://flex.sourceforge.net/manual</a><br/>
</p>
<div id="table-of-contents">
<h2>目录</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1 基本格式</a>
<ul>
<li><a href="#sec-1-1">1.1 正则定义</a></li>
<li><a href="#sec-1-2">1.2 转换规则</a></li>
</ul>
</li>
<li><a href="#sec-2">2 内置变量和函数</a>
<ul>
<li><a href="#sec-2-1">2.1 变量</a></li>
<li><a href="#sec-2-2">2.2 函数</a></li>
<li><a href="#sec-2-3">2.3 yylex</a></li>
<li><a href="#sec-2-4">2.4 yywrap</a></li>
<li><a href="#sec-2-5">2.5 yymore</a></li>
<li><a href="#sec-2-6">2.6 yyless</a></li>
<li><a href="#sec-2-7">2.7 REJECT</a></li>
</ul>
</li>
<li><a href="#sec-3">3 编译</a></li>
<li><a href="#sec-4">4 例子</a></li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> 基本格式</h2>
<div class="outline-text-2" id="text-1">




<pre class="example">%{
这里的代码会原封不动地移到lex编译后的lex.yy.c中
%}
正则定义
%%
转换规则
%%
辅助函数
</pre>


</div>

<div id="outline-container-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> 正则定义</h3>
<div class="outline-text-3" id="text-1-1">

<p>   形如：letter [a-zA-z]，要使用正则定义符号则要在符号外加{}，例如：fuword [aeiou]{letter}*<br/>
</p></div>

</div>

<div id="outline-container-1-2" class="outline-3">
<h3 id="sec-1-2"><span class="section-number-3">1.2</span> 转换规则</h3>
<div class="outline-text-3" id="text-1-2">

<p>   转换规则形如：pattern {action}，例如：<br/>
</p>


<pre class="example">{fuword}      {printf ("%s%s",yytext, "ay");}
</pre>

</div>
</div>

</div>

<div id="outline-container-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> 内置变量和函数</h2>
<div class="outline-text-2" id="text-2">


</div>

<div id="outline-container-2-1" class="outline-3">
<h3 id="sec-2-1"><span class="section-number-3">2.1</span> 变量</h3>
<div class="outline-text-3" id="text-2-1">




<pre class="example">yytext   char *  当前匹配的字符串
yyleng   int     当前匹配的字符串长度
yyin     FILE *  lex当前的解析文件，默认为标准输入
yyout    FILE *  lex解析后的输出文件，默认为标准输出
yylineno int     当前的行数信息
</pre>


<pre class="example">如果命令行参数指定读取来源则打开该文件将FILE指针传递给yyin，否则为标准输入：
int main(int argc, char *argv[])
{
    if (argc&gt;1)
        yyin = fopen(argv[1], "r");
    else
        yyin = stdin;
    yylex();
    return 0;
}
</pre>



<pre class="example">ECHO     #define ECHO fwrite(yytext, yyleng, 1, yyout)  也是未匹配字符的
         默认动作
</pre>

</div>

</div>

<div id="outline-container-2-2" class="outline-3">
<h3 id="sec-2-2"><span class="section-number-3">2.2</span> 函数</h3>
<div class="outline-text-3" id="text-2-2">

</div>

</div>

<div id="outline-container-2-3" class="outline-3">
<h3 id="sec-2-3"><span class="section-number-3">2.3</span> yylex</h3>
<div class="outline-text-3" id="text-2-3">

<p>int yylex(void)    调用Lex进行词法分析<br/>
</p></div>

</div>

<div id="outline-container-2-4" class="outline-3">
<h3 id="sec-2-4"><span class="section-number-3">2.4</span> yywrap</h3>
<div class="outline-text-3" id="text-2-4">




<pre class="example">int yywrap(void)   在文件(或输入)的末尾调用。如果函数的返回值是1，就停止解
                   析。 因此它可以用来解析多个文件。代码可以写在第三段，这
                   样可以解析多个文件。 方法是使用 yyin 文件指针指向不同的
                   文件，直到所有的文件都被解析。最后，yywrap() 可以返回1
                   来表示解析的结束。
</pre>

</div>

</div>

<div id="outline-container-2-5" class="outline-3">
<h3 id="sec-2-5"><span class="section-number-3">2.5</span> yymore</h3>
<div class="outline-text-3" id="text-2-5">

<p>   yymore()           告诉扫描器下次扫描结果连接在当前yytext后而非覆盖当前yytext<br/>
</p>


<pre class="example"> \"[^"]*        {
                if (yytext[yyleng-1] == '\\')
                        yymore();
                else
                        ... normal user processing
                }
对于"abc\"def"情况，第一次扫描得yytex为abc\，判断最后一个字符为\后调用yymore()，则继续扫描得"def并将结果连接到上次结果中得：abc\"def
</pre>

</div>

</div>

<div id="outline-container-2-6" class="outline-3">
<h3 id="sec-2-6"><span class="section-number-3">2.6</span> yyless</h3>
<div class="outline-text-3" id="text-2-6">

<p>   yyless()     回退字符，例如 yyless(yyleng-1)将最后一个字符回退，yyless(yyleng-2)回退两个字符。<br/>
</p></div>

</div>

<div id="outline-container-2-7" class="outline-3">
<h3 id="sec-2-7"><span class="section-number-3">2.7</span> REJECT</h3>
<div class="outline-text-3" id="text-2-7">

<p>   REJECT使用后会进行次好匹配，<br/>
</p>


<pre class="example">%{
#include &lt;stdio.h&gt;
%}

%%
a[bc]+  {printf("%s:%s\n","first rule", yytext); REJECT;}
a[cd]+  {printf ("%s:%s\n","second rule", yytext); REJECT;}
%%
</pre>

<p>
   对于accb,输出：<br/>
</p>


<pre class="example">first rule:accb
first rule:acc
second rule:acc
first rule:ac
second rule:ac
accb
</pre>

<p>
   第1次由a[bc]+匹配到accb，最长，故匹配成功；之后进行次好匹配，a[bc]+匹配到acc，a[cd]+匹配到acc，长度一样，故按照顺序输出，之后a[cb]+又匹配到ac，最后a[cd]+匹配ac，由于它是REJECT的故还想再重新开始匹配，由于没有再匹配的了，所以accb采用默认动作：ECHO－输出。<br/>
</p>
<p>
   将第2个printf中的REJECT删除后：<br/>
</p>


<pre class="example">first rule:accb
first rule:acc
second rule:acc
b
</pre>

<p>
   与上面一样，最后a[cd]+匹配到acc之后由于没有REJECT，forward指针指向b，b没有匹配，默认输出，<br/>
</p></div>
</div>

</div>

<div id="outline-container-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> 编译</h2>
<div class="outline-text-2" id="text-3">

<p>  lex文件以l结尾，lex test.l生成lex.yy.c，之后 cc lex.yy.c -ll生成a.out，再执行./a.out即可。<br/>
</p></div>

</div>

<div id="outline-container-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> 例子</h2>
<div class="outline-text-2" id="text-4">

<ul>
<li>单词序列，如果一个单词第一个字母为元音则将它移动到单词尾并加上ay，否则只在单词后加ay<br/>
</li>
</ul>




<pre class="example">compiler$ cat test.l
%{
    #include &lt;stdio.h&gt;
%}

letter          [a-zA-Z]
yuanword        [aeiou]{letter}*
fuword          [bcdfghjklmnpqrstvwxyz]{letter}*

%%

{yuanword}        {printf("%s%c%s",yytext+1, *yytext, "ay");}
{fuword}      {printf ("%s%s",yytext, "ay");}
%%

compiler$ cat test.c
int main main abc 
compiler$ lex test.l 
compiler$ cc lex.yy.c -o test -ll
compiler$ ./test &lt; test.c
ntiay mainay mainay bcaay 
</pre>

<ul>
<li>将C源程序中所有float关键字变成double<br/>
</li>
</ul>




<pre class="example">compiler$ cat test.l
/* 注意不能将 "a float b"中的float变成double */
/* 所有float声明变量特点是声明或定义，即以;或=紧跟在标识符之后 */
%{
#include &lt;stdio.h&gt;
%}
/* regular definitions */
letter          [a-zA-Z]
digit           [0-9]
id              {letter}({letter}|{digit})*
delim           [ \t]
%%
"float"/{delim}{id}{delim}*(";"|"=")     {printf("%s","double");}
%%

compiler$ cat test.c
int main(int argc, char *argv[])
{
    float i;
    float ii = 1.0;
    char *str = "float";
    char *str2 = "a float b";
    return 0;
}
compiler$ lex test.l
compiler$ cc lex.yy.c -o test -ll
compiler$ ./test &lt; test.c
int main(int argc, char *argv[])
{
    double i;
    double ii = 1.0;
    char *str = "float";
    char *str2 = "a float b";
    return 0;
}
</pre>

<script src="../../Layout/JS/disqus-comment.js"></script>
<div id="disqus_thread">
</div>
</div>
</div>
</div>

</body>
</html>
