#+OPTIONS: ^:{} _:{} num:t toc:t \n:t
#+include "../../template.org"
#+INFOJS_OPT: view:overview mouse:#cccccc toc:t ftoc:t  path:../../Layout/JS/org-info.js
#+title:Emacs Trick

* 用grep在文件中查找
  可以直接在grep buffer中修改文件。
** lgrep
#+begin_quote
(lgrep REGEXP &optional FILES DIR CONFIRM)
#+end_quote
   查找指定目录DIR下指定模式文件FILES内容中符合REGEXP的文件，GREP buffer中n/p上下选择。
** grep
   指定文件中查找
#+begin_quote
grep -nH -e "pattern" filename
#+end_quote
   其中H表输出中包含文件名，n表输出中包含行号，e表紧跟模式
* 执行shell命令
  M-! 执行shell命令
  加前缀C-u执行命令的结果作用在buffer上。
  类似C-u M-|结果作用在region上
* multiple-cursors
#+begin_quote
(global-set-key (kbd "C-S-c C-S-c") 'mc/edit-lines)
(global-set-key (kbd "C-S-c C-e") 'mc/edit-ends-of-lines)
(global-set-key (kbd "C-S-c C-a") 'mc/edit-beginnings-of-lines)
(global-set-key (kbd "C->") 'mc/mark-next-like-this)
(global-set-key (kbd "C-<") 'mc/mark-previous-like-this)
(global-set-key (kbd "C-S-c C-<") 'mc/mark-all-like-this)
(global-set-key (kbd "C-S-c C->") 'mc/mark-all-in-region)
#+end_quote
  先选中一个region，mc/edit-lines则对该region每行都有一个光标。mc/mark-next-like-this在与region内容相同的下一处加一光标。其它函数同理。
* align-regexp
  满足指定正则表达式的对齐，有时对整理注释比较有用。
  其它用法：[[http://emacswiki.org/emacs/AlignCommands][EmacsWiki]]
* list-matching-lines
  列出当前buffer中所有满足指定正则表达式的行
* occur/re-builder/multi-occur/multi-occur-in-matching-buffers
  在进行正则替换行为确保万无一失，先检查一下，occur后输入regexp则会显示所有匹配内容。
  与occur另开一buffer显示匹配不同，re-builder实行动态匹配，即一边在RE-Builder中输入regexp一边匹配（此功能很不错）。
  前面两个都是在当前buffer中匹配，而multi-occur/multi-occur-in-matching-buffers是在多个buffer中匹配
* apropos
  输入一个regexp，Emacs根据你所输入的regexp和当前buffer的内容构造出更多的regexp，也许Emacs构造的比你的更合适的。
* follow-mode
  启用该模式后，C-x 3分屏后，一个文件左右连接显示，适合阅读。
* hexl-mode
  编辑非文本文件。
* backup-by-copying-when-linked
  当文件存在硬链接时默认的备份会破坏这种链接（新建一个文件在新文件中修改，与原来链接文件的inode不同，故与原来链接文件存在链接关系的文件不会同步更新），可以修改当存在链接的时候,通过拷贝来备份，而不是写进一个新文件，故链接关系不会被破坏。
#+begin_quote
(setq backup-by-copying-when-linked t)
#+end_quote
  如果你在使用dropbox这种方法就非常有用，把想要保存在dropbox中的文件硬链接到dropbox目录下，既不占空间又能保持同步更新。

* zap-to-char
  默认绑定到M-z，删除当前位置到下一个输入字符之间的字符，有时候会很有用。
* fill-paragraph
  默认绑定到M-q，调整region,不满一行的由下一行补齐,默认宽度由fill-column变量决定。
* /sudo::/
  如果你用普通用户权限打开emacs，则此时打开超级用户权限的文件是无法修改的，以超级用户重新打开一个emacs可行但考虑到emacs的启动速度，这绝对不是个好主意。
  解决办法：C-x C-f /sudo::/ Enter 之后输入密码即可以超级用户权限打开一个文件。
* 正则表达式
  Emacs中正则表达式要注意group和重复所用的括号需要转义， =\(\)= , =\{3,6\}=
  语法类包括：
#+begin_example
[:digit:]  a digit, same as [0-9]
[:upper:]  a letter in uppercase
[:space:]  a whitespace character, as defined by the syntax table
[:xdigit:] an hexadecimal digit
[:cntrl:]  a control character
[:ascii:]  an ascii character
\s-   whitespace character        \s/   character quote character
\sw   word constituent            \s$   paired delimiter         
\s_   symbol constituent          \s'   expression prefix        
\s.   punctuation character       \s<   comment starter          
\s(   open delimiter character    \s>   comment ender            
\s)   close delimiter character   \s!   generic comment delimiter
\s"   string quote character      \s|   generic string delimiter 
\s\   escape character            
#+end_example
  用re-builder查询时要又重转义即转义字符要转义，即上面的要写成\\(\\), \\{3,6\\}，即要匹配一个字面上的\需要4个\，即\\\\
  re-builder中[:digit:]在写成[和]要写2次.
#+begin_example
"\\(\\+\\|-\\)?[0-9]+\\(\\.[0-9]+\\)?"        表示一个数
"[[:digit:]]\\{3\\}"                          表示连续3个数字
#+end_example

* eshell 别名/使用.bashrc中定义的别名
  Eshell中 find-file filename即可打开文件，等价于C-x C-f filename
  可以定义别名 alias emacs 'find-file $1'，这样在eshell中emacs filename即可打开文件

  我在.bashrc中定义了许多别名，eshell的别名默认保存在 =~/.eshell/alias= 中，由变量 =eshell-aliases-file= 确定，为在方便备份我把它必为 =~/.emacs.d/eshell/alias= ，为了使eshell可以使用这些别名，可以使用下面的命令把所有在shell中可用的别名加到eshell中。
#+begin_example
cd ~/.emacs.d/eshell && cat alias > tmp && echo -e "\n" >> tmp && alias | sed -E "s/^alias ([^=]+)='(.*)'$/alias \1 \2/g; s/'\\\''/'/g;" >> tmp && sort -u tmp > alias && rm -f tmp && sed -i -e '/clc/d' -e '/^$/d'  alias && cd - >/dev/null
#+end_example
  一个很简单的正则替换，其中最后删掉clc行是因为我在shell下用clc充当clear的别名，而此命令在eshell下无效且影响我定义的另一个名为clc的eshell下的孙：
#+begin_src lisp
;; clc 清屏,在eshell中输入命令而非M-x clc
(defun eshell/clc()
  "to clear the eshell buffer."
  (interactive)
  (let ((inhibit-read-only t))
    (erase-buffer)))
#+end_src
  
* 解决org-mode example/src/quote上面多一行问题
  不知道是不是org-mode的bug？如下所示的代码
#+begin_src org
abc
cef
#+begin_example
hello
#+end_example  
#+end_src
  经编译后生成：
#+begin_example
<p>  abc<br/>
  cef<br/>
</p>
<p><br>
<pre class="example">hello
</pre>
</p>
#+end_example
  但浏览器解析是这样解析的：
#+begin_example
<p>  abc<br/>
  cef<br/>
</p>
<p><br></p>
<pre class="example">hello
</pre>
#+end_example
  这样就会在cef和hello之间多出一行。
  分析lisp/org-html.el代码发现原因在:
#+begin_src lisp
;; Check if the line break needs to be conserved
(cond
 ((string-match "\\\\\\\\[ \t]*$" line)
  (setq line (replace-match "<br/>" t t line)))
 (org-export-preserve-breaks
  (setq line (concat line "<br/>"))
  ))
#+end_src
  不管line是否为空都会给line后面加上<br/>，而实际上当Line为空时没有必要加上<br/>，于是可以修改:
#+begin_src lisp
;; Check if the line break needs to be conserved
(cond
 ((string-match "\\\\\\\\[ \t]*$" line)
  (setq line (replace-match "<br/>" t t line)))
 (org-export-preserve-breaks
  (if (not (string= line ""))
      (setq line (concat line "<br/>")))
  ))
#+end_src
  这样便解决了多一行的问题。
* org-mode example/src过大
  当在#+begin_example #+end_example或者#+begin_src #+end_src环境中内容过多时会占用大量空间，一个解决办法是加上 =-t= 选项并配合 =-h height -w width= 选项来指定高宽，使它成为有滚动条的区域。但好像无法使用语法高亮。
* org-mode中使用宏
  在文章的开始定义宏，格式为 #+macro: macro_name macro_content_with_$1_arg1_$2_arg2_...
  在文章中使用宏 {{{macro_name(args)}}}
  其中org-mode内置的宏包括
#+begin_example
{{{title}}}
{{{author}}}
{{{date(format)}}} 其中format格式必须可以被函数 =format-time-string= 识别，常用的包括 %Y-%m-%d-%H-%M-%S 年月日时分秒
%x 格式为： 10/29/2012 
%X 格式为： 11:46:33 AM 
%c 格式为： Mon 29 Oct 2012 11:46:33 AM CST 
%D 格式为： 10/29/12 
%R 格式为： 11:46 
%T 格式为： 11:46:33 
%r 格式为： 11:46:33 AM
还有其它的org中的关键字
#+end_example  
* org-mode 中嵌入latex公式
#+begin_example
$$ \(\)表行内，$$ $$ \[ \] 表行间
#+end_example
#+begin_example
If $a^2=b$ and \( b=2 \), then the solution must be
either $$ a=+\sqrt{2} $$ or \[ a=-\sqrt{2} \].
#+end_example  
* org-mode 中block中嵌入#+begin_example
: #+begin_example
: #+begin_example
: 这种情况导出的不会包含#+begin_example,因为把想要字面导出的#+begin_example当成了example环境
: #+end_example
: #+end_example
  应该这样写
: #+begin_src org
: #+begin_example
: 这样就对了,在这种情况下可以快捷键C-c ' 来进入源码编辑模式
: #+end_example
: #+end_src
  也可以在第行前面加上:空格 来表示字面解析：
#+begin_src org
  ,: #+begin_example
  ,: 这样就对了
  ,: #+end_example
#+end_src
* 分享/评论
#+include "../../disqus.org"
